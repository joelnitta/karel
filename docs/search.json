[{"path":"/articles/a_intro_progrbasics_en.html","id":"some-ideas-about-programming","dir":"Articles","previous_headings":"","what":"Some Ideas about Programming","title":"Introduction and programming basics","text":"Computers essential part daily lives. Almost devices use type computer capable performing certain tasks: washing machines different washing modes, gaming consoles entertainment, powerful calculators, personal computers used various purposes, cell phones countless applications, many . devices different types computers something common: someone “tells ” work, , provide set instructions follow order accomplish task. ’s programming : activity people give computer set instructions solve problem. perform activity called programmers. Without people programming , computers cease useful, matter complex devices may . sets instructions computers receive called programs. Programming creative process: many cases, task can accomplished following different paths, programmer one must imagine paths choose one. paths may better others, case, computer simply follow instructions devised programmer. Unfortunately, computers don’t understand Spanish human language. give instructions language can understand. , need learn programming language, simply artificial language composed series expressions computer can interpret. Computers interpret instructions literally, programming, need specific. must follow rules programming language clear instructions provided. Now, study programming dedicated Statistics? activity statistical professionals entirely intertwined need master computer tools assist us various stages work, data collection cleaning, application different analysis methodologies, effective communication results. ’s tutorial, study basic concepts discipline, fostering exercise abstract logical thinking necessary effectively communicate computer make perform tasks need. programming language used tutorial R, widely used field data science. However, must emphasize R tutorial, meaning focus learning tools language provides data analysis. incorporate basic programming notions, make use help Karel, robot lives walks rectangular worlds. ask Karel perform certain activities, , program R, Karel accompany us first steps take language. Karel Robot programming language created educational purposes Dr. R. E. Pattis Stanford University (California, USA), also wrote book Karel Robot: Gentle Introduction Art Programming 1981. name pays homage Karel Capek, Swedish writer invented word robot science fiction work R.U.R. (Rossum’s Universal Robots). syntax based Pascal, important programming language time. decades, teaching strategy used many places around world, implementing Karel different languages Java, C++, Ruby, Python. Many examples presented guide taken Karel robot learns Java (Eric Roberts). far know, Karel developed R. package first implementation, help us improve notifying us anything notice needs revision! delve playing Karel, let’s review concepts related Programming ’s good keep mind.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"problems-algorithms-and-programming-languages","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Problems, algorithms, and programming languages","title":"Introduction and programming basics","text":"mentioned earlier programming consists instructing computer solve problem, communication instructions must clear. ’s , faced problem needs solved computationally, first step think carefully can solved, words, create algorithm. algorithm consistent strategy ordered set steps leads us solution problem achievement goal. , translate chosen algorithm language computer. Therefore, can say computational resolution problem consists two basic stages: 1.Algorithmic design: develop algorithm, choose existing one, solves problem. 2. Coding: express algorithm programming language computer can interpret execute . learning programming, start facing simple problems first stage seems easy, coding becomes difficult learn rules programming language. However, practice can quickly gain ease writing code, algorithmic design becomes challenging tackle complex problems. ’s emphasize formulation development algorithms fundamental stage programming.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"algorithmic-design","dir":"Articles","previous_headings":"Some Ideas about Programming > Problems, algorithms, and programming languages","what":"Algorithmic Design","title":"Introduction and programming basics","text":"faced problem, first step devise algorithm solution express writing, example, Spanish, adapting human language logical forms resemble tasks computer can perform. programming, artificial informal language developers use creating algorithms called pseudocode. tool use describe algorithms mixing common language programming instructions. programming language , meaning computer capable understanding . purpose pseudocode allow programmer focus logical solution use guide writing program. tutorial, providing examples pseudocode writing. However, important understand attempting program, essential think ahead plan algorithm, .e., steps required reach solution, jot paper pen devising strategy. can great aid process.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"coding","dir":"Articles","previous_headings":"Some Ideas about Programming > Problems, algorithms, and programming languages","what":"Coding","title":"Introduction and programming basics","text":"algorithm presented pseudocode use terms taken Spanish language, reasonable choice sharing strategy among people communicate language. However, want present algorithm someone speaks French, Spanish longer good choice, let alone want present algorithm computer. order computer understand algorithm, need translate programming language, , mentioned , artificial language designed express computations can carried electronic devices; words, means communication humans machines. actions make algorithm encoded one instructions, expressed chosen programming language, collection instructions constitutes program. program saved file name generally divided two parts dot, example: my_first_program.R. first part root name, can describe content file. second part indicates use file, example, .R indicates contains program written R language. general process entering modifying content file called editing.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"programming-errors","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Programming Errors","title":"Introduction and programming basics","text":"soon embark journey world programming, realize always certain companions: errors. Many times, try run code won’t work produce expected result. matter careful much experience , errors always present. time practice, able identify correct easily, probably never stop making . something discouraged , solving errors make often leads great learning experiences. Programming errors often called bugs, process correcting known debugging. said terminology dates back 1947 computer Harvard University (Mark II) stopped working, eventually discovered cause problem moth found one machine’s electromagnetic relays. However, historians argue term already use .","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"processor-environment-and-actions","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Processor, Environment, and Actions","title":"Introduction and programming basics","text":"defined algorithm list instructions solving problem. context, term processor refers agent capable understanding steps algorithm carrying work indicated . achieve goal, processor uses certain resources available . elements available used processor constitute environment. instructions make algorithm modifies environment way called action.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"r-and-rstudio","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"R and RStudio","title":"Introduction and programming basics","text":"mentioned earlier, put practice programming concepts using R. Unlike many languages, R free open-source software distributed GNU GPLv2 license, allows freedom use purpose, see made, works, modify , distribute copies, create contributions additions available others 1. Although R means communication computer, use another program provides tools facilitate programming work. words, use integrated development environment (IDE). IDE program makes coding easier allowing us manage multiple code files, visualize working environment, use color highlighting different parts code, employ autocomplete write faster, explore help pages, implement debugging strategies, even interactively execute instructions viewing results progress analyzing solving problem. popularly used IDE programming R RStudio, program ’ll using time. install programs, visit official websites R RStudio, download installers, run . can find complete installation guide link. R active user community various fields, many blogs, portals, -person meetings seek receive help. ↩︎","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"organization-of-rstudio","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"Organization of RStudio","title":"Introduction and programming basics","text":"open RStudio, see four panels: Captura de pantalla de RStudio left: top file editor. write edit programs, save (similar simple Notepad Word document). first time open RStudio installation, panel may present, appears go File > New File > R Script, use shortcut Ctrl + Shift + N, click first icon toolbar. can open multiple files . console. window communicates R. console, send instructions R evaluation (also known running executing ), results displayed . top-right corner, panel several tabs: Environment: displays elements make environment. History: lists instructions R previously run. tabs relevant now. bottom-right corner, another panel additional tabs: Files: file explorer computer. Plots: window graphics appear code produces . Packages: list installed “packages” (later). Help: help manual covering functions R. Viewer: space view program outputs dynamic interactive components.","code":""},{"path":"/articles/a_intro_progrbasics_en.html","id":"using-the-console","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"Using the Console","title":"Introduction and programming basics","text":"can use R console found left panel enter instructions , press Enter, evaluated, producing results. example, can perform mathematical calculations division, multiplication, addition, subtraction, exponentiation, logarithms, square roots, : can write instructions console press Enter execute , generally, want write save code file. ’s write programs top-left panel. write instruction script, can run (.e., send console execution) clicking Run button using shortcut Ctrl + Enter. way, line cursor selected lines run. every programming language, special character , placed beginning code line, tells software line evaluated. used include comments, lines express explanations clarifications natural language others may use code. Comments also used add headers descriptions script indicate different sections parts program. R, special character number symbol (#). run lines begin #, R ignore skip . example:","code":"1 + 2 #> [1] 3 5 * 3 #> [1] 15 exp(2) #> [1] 7.389056 sqrt(100) #> [1] 10 1 / 0 #> [1] Inf (2 + 3i) * (3 + 6i) #> [1] -12+21i 1i ^ 2 #> [1] -1+0i 5^1 #> [1] 5 # 5^2 5^3 #> [1] 125"},{"path":[]},{"path":"/articles/a_intro_progrbasics_en.html","id":"r-system-design","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"R System Design","title":"Introduction and programming basics","text":"R divided two parts: base (R Base), installed download program CRAN (Comprehensive R Archive Network). contains, among things, set basic fundamental tools R. Additional packages. package set files can optionally downloaded CRAN repositories used perform specific tasks. example, work Karel, need install package contains implementation, called karel. mentioned earlier, Packages tab bottom-right panel displays list packages already installed (many come R Base). also button install new packages CRAN. Alternatively, can run command install.packages(\"packagename\") install package: also possible install packages published repositories. example, common download packages development experimentation available GitHub platform. packages can installed specifying GitHub account name package author package name. want install development version karel package (necessary), following: package installed , every time want use , need load tools become available us. done library(\"packagename\") command, example, library(\"karel\").","code":"# Instalar desde CRAN el paquete karel install.packages(\"karel\") # Instalar desde CRAN el paquete devtools install.packages(\"devtools\") # Instalar desde GitHub el paquete karel devtools::install_github(\"mpru/karel\")"},{"path":"/articles/a_intro_progrbasics_es.html","id":"algunas-ideas-sobre-programación","dir":"Articles","previous_headings":"","what":"Algunas ideas sobre Programación","title":"Introducción y nociones básicas sobre programación","text":"Podés encontrar una versión más extensa de esta introducción en esta Guía de Estudio. Las computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen algún tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras súper potentes, computadoras personales que se usan para un montón de propósitos, teléfonos celulares con un sinfín de aplicaciones y miles de cosas más. Todos estos dispositivos con computadoras de distinto tipo tienen algo en común: alguien “les dice” cómo funcionar, es decir, les indica cuáles son los pasos que deben seguir para cumplir una tarea. De eso se trata la programación: es la actividad mediante la cual las personas le entregan una computadora un conjunto de instrucciones para que, al ejecutarlas, ésta pueda resolver un problema. Quienes realizan esta actividad reciben el nombre de programadores. Sin las personas que las programen, las computadoras dejan de ser útiles, por más complejos que sean estos aparatos. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de programas. La programación es un proceso creativo: en muchas ocasiones la tarea en cuestión puede cumplirse siguiendo distintos caminos y el programador es el que debe imaginar cuáles son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitará seguir las instrucciones ideadas por el programador. Desafortunadamente, las computadoras entienden español ni otro idioma humano. Hay que pasarles las instrucciones en un lenguaje que sean capaces de entender. Para eso debemos aprender algún lenguaje de programación, que es más que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto la hora de programar hay que ser muy específicos. Es necesario respetar las reglas del lenguaje de programación y ser claros en las indicaciones provistas. Ahora bien, ¿por qué debemos estudiar programación en si nos dedicamos la Estadística? La actividad de los profesionales estadísticos está atravesada en su totalidad por la necesidad de manejar con soltura herramientas informáticas que nos asisten en las distintas etapas de nuestra labor, desde la recolección y depuración de conjuntos de datos, pasando por la aplicación de distintas metodologías de análisis, hasta la comunicación efectiva de los resultados. Por eso, en este tutorial estudiaremos los conceptos básicos de esta disciplina, fomentando la ejercitación del pensamiento abstracto y lógico necesario para poder entendernos hábilmente con la computadora y lograr que la misma realice las tareas que necesitamos. El lengua de programación en el que se basa este tutorial es R, ampliamente empleado en el ámbito de la ciencia de datos. Sin embargo, debemos resaltar que éste es un tutorial sobre R, es decir, nos dedicaremos aprender las herramientas que este lenguaje brinda para el análisis de datos. Para incorporar algunas nociones básicas de programación vamos valernos de la ayuda de Karel, una robot que vive y camina por mundos rectangulares. Vamos pedirle Karel que realice ciertas actividades y para esto tenemos que programar en R, de modo que Karel nos acompañará en los primeros pasos que demos con este lenguaje. Karel Robot es un lenguaje de programación creado con fines educativos por el Dr. R. E. Pattis de la Universidad de Stanford (California, EEUU), quien también escribió el libro Karel Robot: Gentle Introduction Art Programming en 1981. Su nombre es un homenaje Karel Capek, el escritor sueco que inventó la palabra robot en su obra de ciencia ficción R.U.R. (Rossum’s Universal Robots). Su sintaxis se basaba en Pascal, un lenguaje de programación muy importante en aquellos tiempos. lo largo de las décadas, esta estrategia de enseñanza fue utilizada en muchos lugares alrededor del mundo, implementando Karel en distintos lenguajes como Java, C++, Ruby y Python. Muchos de los ejemplos presentados en esta guía fueron tomados de Karel robot learns Java (Eric Roberts, 2005). Hasta donde sabemos, Karel había sido desarrollado en R. Nuestro paquete es la primera implementación, ¡ayudanos mejorarlo avisándonos cualquier cosa que notes que necesite revisión! Pero antes de meternos de lleno jugar con Karel, vamos repasar algunos conceptos relativos la Programación que viene bien tener presentea.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"problemas-algoritmos-y-lenguajes-de-programación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Problemas, algoritmos y lenguajes de programación","title":"Introducción y nociones básicas sobre programación","text":"Mencionamos anteriormente que la programación consistía en instruir una computadora para que resuelva un problema y que la comunicación de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cuál puede ser una forma de resolverlo, es decir, crear un algoritmo. Un algoritmo es una estrategia consistente de un conjunto ordenado de pasos que nos lleva la solución de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora. Entonces, podemos decir que la resolución computacional de un problema consiste de dos etapas básicas: Diseño algorítmico: desarrollar un algoritmo, o elegir uno existente, que resuelva el problema. Codificación: expresar un algoritmo en un lenguaje de programación para que la computadora lo pueda interpretar y ejecutar. Al aprender sobre programación, comenzamos enfrentándonos problemas simples para los cuales la primera etapa parece sencilla, mientras que la codificación se torna dificultosa ya que hay que aprender las reglas del lenguaje de programación. Sin embargo, mientras que con práctica rápidamente podemos ganar facilidad para la escritura de código, el diseño algorítmico se torna cada vez más desafiante al encarar problemas más complejos. Es por eso que haremos hincapié en el planteo y desarrollo de algoritmos como una etapa fundamental en la programación.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"el-diseño-algorítmico","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > Problemas, algoritmos y lenguajes de programación","what":"El diseño algorítmico","title":"Introducción y nociones básicas sobre programación","text":"Frente cada problema, el primer paso es idear un algoritmo para su solución y expresarlo por escrito, por ejemplo, en español, pero adaptando el lenguaje humano formas lógicas que se acerquen las tareas que puede realizar una computadora. En programación, el lenguaje artificial e informal que usan los desarrolladores en la confección de algoritmos recibe el nombre de pseudocódigo. Es la herramienta que utilizamos para describir los algoritmos mezclando el lenguaje común con instrucciones de programación. es en sí mismo un lenguaje de programación, es decir, la computadora es capaz de entenderlo, sino que el objetivo del mismo es que el programador se centre en la solución lógica y luego lo utilice como guía al escribir el programa. En este tutorial vamos estar presentando ejemplos de escritura con pseudocódigo. Sin embargo, tenemos que tener en claro que antes de intentar programar, es importante pensar con anticipación el algoritmo, es decir, todos los pasos para llegar la solución y anotarlos en papel y birome mientras ideamos una estrategia puede ser una gran ayuda.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"codificación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > Problemas, algoritmos y lenguajes de programación","what":"Codificación","title":"Introducción y nociones básicas sobre programación","text":"Un algoritmo presentado en pseudocódigo podría utilizar términos tomados del lenguaje español, una opción razonable para compartir esta estrategia entre personas que se comuniquen con este idioma. Claramente, si queremos presentarle nuestro algoritmo alguien que sólo habla francés, el español ya sería una buena elección y mucho menos si queremos presentarle el algoritmo una computadora. Para que una computadora pueda entender nuestro algoritmo, debemos traducirlo en un lenguaje de programación, que, como dijimos antes, es un idioma artificial diseñado para expresar cómputos que puedan ser llevados cabo por equipos electrónicos, es decir es un medio de comunicación entre el humano y la máquina. Cada una de las acciones que componen al algoritmo son codificadas con una o varias instrucciones, expresadas en el lenguaje de programación elegido, y el conjunto de todas ellas constituye un programa. El programa se guarda en un archivo con un nombre generalmente dividido en dos partes por un punto, por ejemplo: mi_primer_programa.R. La primera parte es la raíz del nombre con la cual podemos describir el contenido del archivo. La segunda parte es indicativa del uso del archivo, por ejemplo, .R indica que contiene un programa escrito en el lenguaje R. El proceso general de ingresar o modificar el contenido de un archivo se denomina edición.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"errores-de-programación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Errores de programación","title":"Introducción y nociones básicas sobre programación","text":"Apenas iniciemos nuestro camino en el mundo de la programación nos daremos cuenta que tendremos siempre ciertos compañeros de viaje: los errores. Muchas veces nos pasará que queremos ejecutar nuestro código y el mismo anda o produce el resultado esperado. importa cuán cuidadosos seamos, ni cuánta experiencia tengamos, los errores están siempre presentes. Con el tiempo y práctica, vamos poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos. Esto es para amargarse, puesto que través de la solución de los errores cometidos muchas veces se producen grandes aprendizajes. los errores en programación se los suele llamar bugs (insecto o bicho en inglés) y el proceso de la corrección de los mismos se conoce como debugging (depuración)1. Se dice que esta terminología proviene de 1947, cuando una computadora en la Universidad de Harvard (la Mark II) dejó de funcionar y finalmente se descubrió que la causa del problema era la presencia de una polilla en un relé electromagnético de la máquina. Sin embargo, otros historiadores sostienen que el término ya se usaba desde antes.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"procesador-ambiente-y-acciones","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Procesador, ambiente y acciones","title":"Introducción y nociones básicas sobre programación","text":"Hemos definido un algoritmo como una lista de instrucciones para resolver un problema. En este contexto, se entiende por procesador todo agente capaz de comprender los pasos de un algoritmo y ejecutar el trabajo indicado por el mismo. Para cumplir con el objetivo, el procesador emplea ciertos recursos que tiene disposición. Todos los elementos disponibles para ser utilizados por el procesador constituyen su entorno o ambiente. Cada una de las instrucciones que componen el algoritmo modifican el entorno de alguna manera y se denominan acciones.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"r-y-rstudio","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"R y RStudio","title":"Introducción y nociones básicas sobre programación","text":"Como dijimos anteriormente, pondremos en práctica los conceptos sobre programación utilizando R. diferencia de muchos otros, este es un software libre y gratuito: se distribuye bajo la licencia GNU GPLv2 que establece la libertad de usarlo con cualquier propósito, de ver cómo fue hecho, cómo funciona y modificarlo, de distribuir copias y crear contribuciones y agregados para que estén disponibles para otros 2. Si bien R será nuestro medio de comunicación con la computadora, vamos usar otro programa que brinda algunas herramientas para facilitar nuestro trabajo de programación, es decir, vamos usar un entorno de desarrollo integrado (o IDE, por integrated development environment). Un IDE es un programa que hace que la codificación sea más sencilla porque permite manejar varios archivos de código, visualizar el ambiente de trabajo, utilizar resaltado con colores para distintas partes del código, emplear autocompletado para escribir más rápido, explorar páginas de ayuda, implementar estrategias de depuración e incluso intercalar la ejecución de instrucciones con la visualización de los resultados mientras avanzamos en el análisis o solución del problema. El IDE más popularmente empleado para programar con R es RStudio y será el programa que estaremos usando todo el tiempo. Para instalar estos programas, se debe visitar las páginas oficiales de R y de RStudio, descargar los instaladores y ejecutarlos. En este enlace se presenta un video con la instalación completa.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"organización-de-rstudio","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Organización de RStudio","title":"Introducción y nociones básicas sobre programación","text":"Cuando se abre RStudio se pueden visualizar cuatro paneles: Captura de pantalla de RStudio la izquierda: Arriba está el editor de archivos. Es el lugar donde escribiremos y editaremos nuestros programas, para luego guardarlos (una especie de Bloc de Notas o de un Word muy simple). La primera vez que se abre RStudio después de su instalación puede ser que este panel esté presente, pero aparece si vamos File > New File > R Script, con el atajo Ctrl + Shift + N o haciendo clic en el primer ícono de la barra de herramientas. Podemos abrir varios archivos la vez. Abajo está la consola. Es la ventana que se comunica con R. través de ella se envían las instrucciones R para que las evalúe (también decimos, que las ejecute o corra) y se visualizan los resultados. Arriba la derecha hay un panel con algunas pestañas: Environment (ambiente): muestra todos los elementos que componen al ambiente o entorno. History (historial): lista todas las instrucciones que R ha corrido anteriormente. Otras más que nos interesan por ahora. Abajo la derecha hay otro panel con más pestañas: Files: explorador de archivos de la computadora. Plots: ventana donde aparecen los gráficos si es que nuestro código produce alguno. Packages: listado de los “paquetes” que tenemos instalados (ver más adelante). Help: manual de ayuda sobre todas las funciones de R. Viewer: espacio para ver salidas de los programas con algún componente dinámico o interactivo.","code":""},{"path":"/articles/a_intro_progrbasics_es.html","id":"uso-de-la-consola","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Uso de la consola","title":"Introducción y nociones básicas sobre programación","text":"Podemos usar la consola de R que encontramos en el panel de la izquierda para introducir allí nuestras instrucciones y al hacer Enter serán evaluadas, produciendo algún resultado. Por ejemplo, podemos hacer algunos cálculos matemáticos como dividir, multiplicar, sumar, restar, calcular potencias, logaritmos, raíces y mucho más: Si bien podemos escribir nuestras instrucciones en la consola y dar Enter para que se ejecuten, en general queremos que queden escritas y guardadas en el archivo de código, por eso vamos escribir nuestros programas en el panel de arriba la izquierda. Una vez que escribimos una instrucción en el script, podemos correrla (es decir, enviarla la consola para que se ejecute) haciendo clic en el ícono Run o con el atajo Ctrl + Enter. De esta forma, se corre la línea en la cual está el cursor o las líneas que hayamos seleccionado. En todo lenguaje de programación existe un caracter especial que, al ser colocado al comienzo de una línea de código, le indica al software que dicha línea debe ser evaluada. Esto se utiliza para incluir comentarios, es decir, líneas que expresan en español explicaciones o aclaraciones para nosotros mismos u otros que puedan utilizar nuestro código. También se utiliza para añadir encabezados con descripciones sobre el script, o indicar distintas secciones o partes en el programa. En R, este caracter especial es el símbolo numera (#). Si corremos líneas que empiezan con #, R hará nada con ellas, las salteará. Por ejemplo","code":"1 + 2 #> [1] 3 5 * 3 #> [1] 15 exp(2) #> [1] 7.389056 sqrt(100) #> [1] 10 1 / 0 #> [1] Inf (2 + 3i) * (3 + 6i) #> [1] -12+21i 1i ^ 2 #> [1] -1+0i 5^1 #> [1] 5 # 5^2 5^3 #> [1] 125"},{"path":"/articles/a_intro_progrbasics_es.html","id":"diseño-del-sistema-r","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Diseño del sistema R","title":"Introducción y nociones básicas sobre programación","text":"R se divide en dos partes: La base (R Base), que se instala cuando descargamos el programa desde CRAN (“Comprehensive R Archive Network”). Contiene, entre otras cosas, una serie de herramientas básicas y fundamentales de R. Paquetes adicionales. Un paquete es un conjunto de archivos que se descarga de forma opcional desde CRAN u otros repositorios y que sirven para hacer alguna tarea especial. Por ejemplo, para poder jugar con Karel deberemos instalar el paquete que contiene su implementación, llamado karel. Como dijimos antes, en la pestaña Packages del panel de abajo la derecha tiene el listado de todos los paquetes que ya están instalados (muchos vienen con R Base). Allí también hay un botón para instalar nuevos desde CRAN, aunque otra opción es correr la instrucción install.packages(\"nombredelpaquete\"): También es posible instalar paquetes publicados en otros repositorios. Por ejemplo, es muy común descargar paquetes en desarrollo o en experimentación que estén disponibles en la plataforma Github. Estos paquetes se instalan especificando el nombre de la cuenta de Github de quien lo haya publicado y el nombre del paquete. Si queremos instalar la versión en desarrollo del paquete karel (es necesario) deberíamos hacer: Un paquete se instala una sola vez, pero cada vez que lo queramos usar debemos cargarlo para que las herramientas que trae queden nuestra disposición. Eso se hace con la instrucción library(\"nombredelpaquete\"), por ejemplo, library(\"karel\").","code":"# Instalar desde CRAN el paquete karel install.packages(\"karel\") # Instalar desde CRAN el paquete devtools install.packages(\"devtools\") # Instalar desde GitHub el paquete karel devtools::install_github(\"mpru/karel\")"},{"path":"/articles/aa_get_started_en.html","id":"who-is-karel","dir":"Articles","previous_headings":"","what":"Who is Karel?","title":"Get started with Karel the robot","text":"karel new R package created purpose providing environment enables teaching programming principles dynamic interactive way, students previous experience studying secondary level early years undergraduate education. Karel robot lives walks certain worlds, can perform certain actions ask , learn program R. robot Karel assists teaching fundamental programming concepts, processor (Karel), environment (world), objects (called beepers), actions (activities can perform). addition, can seen examples tutorials presented page, along Karel, possible instruct concept algorithmic decomposition: numerous occasions, robot must fulfill objectives whose resolution requires breaking problem smaller parts, students must program function R. also facilitates exemplification use sequential code control structures, conditionals (() {} else {}), iterative structures (() {}, () {}). first step programming Karel generate world can move, using instruction generate_world(), specifying name world want use within parentheses. package includes predefined worlds, users can choose create new ones. Karel’s worlds rectangular, composed streets run horizontally (rows) vertical avenues (columns). Karel always located intersection street avenue (cell), facing one four possible directions: east, north, west, south. black borders represent walls Karel cross; can go around . Additionally, cells, one several beepers. Karel can traverse world picking placing beepers; picks , stores backpack keeps track many . Finally, Karel can perform following activities: move(), turn_left(), pick_beeper() (pick coso), put_beeper(). However, cleverly combining basic actions, new ones can created. example, function turn_right() can created making Karel turn left three times. Furthermore, Karel capable evaluating certain characteristics environment functions return logical value TRUE FALSE, example: front_is_clear() (front open), beepers_present() facing_south(). allows us condition actions Karel performs based certain aspects position world. code actions Karel must perform executed, function run_actions() must run, result can seen animation created ggplot gganimate packages. order overcome language barriers can make taking first steps learning programming challenging, karel package designed completely bilingual: functions version Spanish English (example, girar_izquierda() turn_left()), help manual pages website pages written languages. idea implementation package based Karel Robot, programming language created educational purposes Dr. R. E. Pattis Stanford University (California, USA), also wrote book Karel Robot: Gentle Introduction Art Programming 1981. name pays homage Karel Capek, Swedish writer coined word “robot” science fiction work R.U.R. (Rossum’s Universal Robots). syntax based Pascal, decades, teaching strategy implemented different languages Java, C++, Ruby, Python. package presented first implementation Karel R. examples included vignettes adaptations published Eric Roberts material Karel robot learns Java (2005).","code":""},{"path":"/articles/aa_get_started_en.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Get started with Karel the robot","text":"can install karel CRAN: can also install development version GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"mpru/karel\")"},{"path":"/articles/aa_get_started_en.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"Get started with Karel the robot","text":"Can write program Karel place beepers vertices diamond enclosed ?  Maybe doint ?  Now Karel maze. Can make reach end?  Yes, code:  can see details examples others tutorials section.","code":"# Load the package and Karel's superpowers library(karel) load_super_karel()  # Create new functions walk_diagonal <- function() {     while (front_is_clear()) {         move()         turn_left()         move()         turn_right()     } }  # Solve the problem generate_world(\"mundo019\") for (i in 1:4) {     walk_diagonal()     put_beeper()     turn_right() } run_actions() generate_world(\"mundo009\") while (no_beepers_present()) {   turn_right()   while (front_is_blocked()) {     turn_left()   }   move() } run_actions()"},{"path":"/articles/aa_get_started_es.html","id":"quién-es-karel","dir":"Articles","previous_headings":"","what":"¿Quién es Karel?","title":"Primeros pasos con la robot Karel","text":"karel un nuevo paquete de R creado con el propósito de brindar un entorno que posibilite la enseñanza de principios de la programación en una forma dinámica e interactiva, para estudiantes sin experiencia previa que estén cursando el nivel secundario o los primeros años de su formación de grado. Karel es una robot que vive y camina por ciertos mundos, en los cuales puede realizar determinadas acciones si se lo pedimos, mientras aprendemos programar en R. La robot Karel acompaña en la enseñanza de conceptos fundamentales de la programación, por ejemplo, el de procesador (Karel), ambiente (su mundo), objetos (llamados cosos) y acciones (las actividades que puede realizar). Además, como se puede observar en los ejemplos de los tutoriales presentes en esta página, junto con Karel es posible instruir sobre el concepto de la descomposición algorítmica: en numerosas oportunidades la robot debe cumplir objetivos cuya resolución requiere descomponer el problema en partes más pequeñas, para cada una de las cuales los estudiantes deben programar una función en R. También facilita la ejemplificación del uso de estructuras de control de código secuenciales, condicionales (() {} else {}) e iterativas (() {}, () {}). El primer paso para programar con Karel es generar un mundo en el cual ella pueda andar, través de la instrucción generar_mundo(), aclarando entre los paréntesis el nombre del mundo que queremos usar. El paquete trae incorporados unos cuantos pero los usuarios pueden optar por crear otros nuevos. Todos los mundos de Karel son rectangulares, compuestos por calles que los recorren horizontalmente (filas) y avenidas verticales (columnas). Karel siempre se encuentra en la intersección entre una calle y una avenida (celda), mirando hacia una de las cuatro direcciones posibles: este, norte, oeste o sur. Los bordes negros representan paredes que Karel puede atravesar, solo puede rodearlas. Además, en algunas celdas hay uno o varios cosos. Karel puede recorrer el mundo poniendo y juntando cosos por ahí; si los junta los guarda en su mochila y lleva un registro de cuántos tiene. Finalmente, Karel solo puede realizar estas actividades: avanzar(), girar_izquierda(), juntar_coso() y poner_coso(). Claro, agrupando ingeniosamente estas acciones básicas se pueden crear otras nuevas, por ejemplo, crear una función girar_derecha() que produzca tal efecto, haciendo girar Karel tres veces la izquierda. Por otro lado, Karel es capaz de evaluar ciertas características de su entorno través de funciones que arrojan un valor lógico TRUE o FALSE, por ejemplo: frente_abierto(), hay_cosos() o mira_al_sur(), de manera que podemos condicionar las acciones que Karel realiza la verificación de ciertos aspectos sobre su posición y su mundo. Una vez que se ejecuta el código con todas las acciones que Karel debe realizar, se debe correr la función ejecutar_acciones() y se puede ver el resultado en una animación creada con los paquetes ggplot y gganimate. Con el objetivo de sortear algunas de las barreras idiomáticas que pueden hacer más desafiante poder dar los primeros pasos en el aprendizaje de programación, el paquete karel se diseñó de forma completamente bilingüe: todas las funciones tienen una versión en español y en inglés (por ejemplo,girar_izquierda() y turn_left()), así como también las páginas del manual de ayuda y algunas del sitio web están escritos en ambos idiomas. La idea para la implementación de este paquete se basa en Karel Robot, un lenguaje de programación creado con fines educativos por el Dr. R. E. Pattis de la Universidad de Stanford (California, EEUU), quien también escribió el libro Karel Robot: Gentle Introduction Art Programming, en 1981. Su nombre es un homenaje Karel Capek, el escritor sueco que inventó la palabra robot en su obra de ciencia ficción R.U.R. (Rossum’s Universal Robots). Su sintaxis se basaba en Pascal, pero lo largo de las décadas esta estrategia de enseñanza fue implementada en distintos lenguajes como Java, C++, Ruby y Python. El paquete aquí presentado es la primera implementación de Karel para R. Algunos de los ejemplos incluidos en las viñetas son adaptaciones de aquellos publicados por Eric Roberts en su material Karel robot learns Java (2005).","code":""},{"path":"/articles/aa_get_started_es.html","id":"instalación","dir":"Articles","previous_headings":"","what":"Instalación","title":"Primeros pasos con la robot Karel","text":"Podés instalar karel desde CRAN: También podés instalar la versión en desarrollo desde GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"mpru/karel\")"},{"path":"/articles/aa_get_started_es.html","id":"ejemplos","dir":"Articles","previous_headings":"","what":"Ejemplos","title":"Primeros pasos con la robot Karel","text":"¿Podés escribir un programa para que Karel coloque cosos en los vértices del rombo en en el cual está encerrada?  ¿Algo así, tal vez?  Ahora Karel está en un laberinto. ¿Podemos hacerla llegar hasta el final?  Sí, con este código:  Podés ver más detalles sobre estos ejemplos y otros en la sección de tutoriales.","code":"# Cargar el paquete y los superpoderes de Karel library(karel) cargar_super_karel()  # Crear funciones auxiliares recorrer_diagonal <- function() {     while (frente_abierto()) {         avanzar()         girar_izquierda()         avanzar()         girar_derecha()     } }  # Implementar el problema generar_mundo(\"mundo019\") for (i in 1:4) {     recorrer_diagonal()     poner_coso()     girar_derecha() } ejecutar_acciones() generar_mundo(\"mundo009\") while (no_hay_cosos()) {   girar_derecha()   while (frente_cerrado()) {     girar_izquierda()   }   avanzar() } ejecutar_acciones()"},{"path":"/articles/c_decomposition_es.html","id":"girar-a-la-derecha","dir":"Articles","previous_headings":"","what":"Girar a la derecha","title":"Descomposición algorítmica","text":"Para empezar con algo sencillo, en el ejemplo visto en la sección anterior Karel necesitaba doblar la derecha y lo logramos indicándole que gire tres veces la izquierda. Esto es medio molesto, primero porque mentalmente nos imaginamos otra cosa cuando queremos que Karel gire la derecha y segundo porque probablemente Karel tenga que girar la derecha en muchos problemas y vamos querer repetir tantas veces girar_izquierda(). Por eso, es muy razonable crear una nueva función para que se encargue de esto. Cada vez que nos damos cuenta de que estamos usando una secuencia de comandos de Karel con el objetivo de cumplir una tarea específica, como doblar la derecha, entonces es momento de definir una nueva función que englobe esos comandos: De manera general, en R una función se crea con estos pasos: Elegir nombre: girar_derecha Usar el operador de asignación (o flechita, <-) para asociar ese nombre la definición de una función. Escribir la instrucción function() {...}, donde lo que va entre llaves es el conjunto de acciones que engloba la nueva función, una en cada renglón: Con la ayuda de este subalgoritmo, podemos apreciar cómo se simplifica la escritura del código. Es importante notar que, para que podamos usar la función girar_izquierda(), la misma tiene que ser definida y evaluada por R antes de que hagamos uso de la misma para resolver nuestro problema:  EJERCICIO: crear una función llamada darse_vuelta() que le permita Karel realizar un giro de 180 grados y quedar mirando hacia la dirección contraria.","code":"girar_derecha <- function() {   girar_izquierda()   girar_izquierda()   girar_izquierda() } nombre <- function() {   ... instrucciones de R ... } #  --------------- Cargar paquete Karel -------------------- library(karel)  # ------------ Definición de funciones auxiliares-----------  girar_derecha <- function() {   girar_izquierda()   girar_izquierda()   girar_izquierda() }  # ---------------- Programa principal ----------------------  generar_mundo(\"mundo001\") avanzar() juntar_coso() avanzar() girar_izquierda() avanzar() girar_derecha() avanzar() avanzar() poner_coso() avanzar() ejecutar_acciones()"},{"path":"/articles/c_decomposition_es.html","id":"los-superpoderes-de-karel","dir":"Articles","previous_headings":"","what":"Los superpoderes de Karel","title":"Descomposición algorítmica","text":"En la sección anterior hemos creado las funciones girar_derecha() y darse_vuelta() por nuestros propios medios para aprender cómo generar nuevos subalgoritmos. Sin embargo, para agilizar la creación de nuestros programas y la visualización de lo que hace Karel, el paquete de R trae incorporadas mejores versiones de girar_derecha() y darse_vuelta(). Para que estén disponibles y las podamos usar, tenemos que activar estos superpoderes de Karel con la siguiente sentencia, que puede ser ejecutada en cualquier momento (luego de library(karel) sería un buen lugar):","code":"library(karel) cargar_super_karel()"},{"path":"/articles/c_decomposition_es.html","id":"llenar-el-agujero","dir":"Articles","previous_headings":"","what":"Llenar el agujero","title":"Descomposición algorítmica","text":"Veamos otro ejemplo sobre la utilidad de la descomposición algorítmica. Como ocurre en muchos lugares, en el mundo de Karel veces las calles necesitan reparación. Imaginemos que Karel está caminando por la calle como se ve en la figura de la izquierda y se encuentra con un agujero. Su tarea es rellenarlo con un coso y avanzar hasta el otro extremo, como se ve en la figura de la derecha.  Si nos limitamos los comandos básicos de Karel, el programa que permite resolver esto es: Si en cambio usamos nuestras propias funciones girar_derecha() y darse_vuelta(), el programa queda más corto y claro: Ahora bien, el proceso de llenar el agujero es una tarea muy concreta que puede ser pensada como un problema en sí mismo, que se puede resolver por fuera del algoritmo principal. Podemos definir un nuevo subalgoritmo que se encargue específicamente de esto y que pueda ser reutilizado en otras ocasiones. Siguiendo entonces la idea de la descomposición algorítmica, el problema que estamos analizando puede ser descompuesto de esta forma:","code":"generar_mundo(\"mundo002\") avanzar() girar_izquierda() girar_izquierda() girar_izquierda() avanzar() poner_coso() girar_izquierda() girar_izquierda() avanzar() girar_izquierda() girar_izquierda() girar_izquierda() avanzar() ejecutar_acciones() generar_mundo(\"mundo002\") avanzar() girar_derecha() avanzar() poner_coso() darse_vuelta() avanzar() girar_derecha() avanzar() ejecutar_acciones() #  --------------- Cargar paquete Karel --------------------  library(karel) cargar_super_karel() # pone a disposición girar_derecha() y darse_vuelta()  # ------------ Definición de funciones auxiliares-----------  llenar_agujero <- function() {   girar_derecha()   avanzar()   poner_coso()   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal -------------------- generar_mundo(\"mundo002\") avanzar() llenar_agujero() avanzar() ejecutar_acciones()"},{"path":"/articles/c_decomposition_es.html","id":"documentación-de-los-subalgoritmos","dir":"Articles","previous_headings":"","what":"Documentación de los subalgoritmos","title":"Descomposición algorítmica","text":"En el contexto de la programación, documentar significa escribir indicaciones para que otras personas puedan entender lo que queremos hacer en nuestro código o para que sepan cómo usar nuestras funciones. Por ejemplo, como vimos antes todas funciones predefinidas de R están documentadas para que podamos buscar ayuda si la necesitamos. Cuando estamos creando nuestras propios subalgoritmos, es importante que también incluyamos comentarios para guiar otras personas (y nosotros mismos en el futuro si nos olvidamos) para qué y cómo se usa lo que estamos desarrollando. Por ejemplo, puede ser bueno que enunciemos el nombre de la función y aclaremos bajo qué condición inicial se puede utilizar y qué resultado final arroja, por ejemplo: Algunos ejemplos presentados en este tutorial fueron adaptados de Karel robot learns Java (Eric Roberts, 2005).","code":"#  --------------- Cargar paquete Karel --------------------  library(karel) cargar_super_karel()  # ------------ Definición de funciones auxiliares-----------  # Función: llenar_agujero # Condición inicial: Karel se encuentra sobre el agujero (en la calle anterior), # mirando al este # Condición final: Karel se encuentra en la misma posición que al inicio y ha # colocado un coso en el agujero llenar_agujero <- function() {   girar_derecha()   avanzar()   poner_coso()   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal ------------------- generar_mundo(\"mundo002\") avanzar() llenar_agujero() avanzar() ejecutar_acciones()"},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-de-control-secuenciales","dir":"Articles","previous_headings":"","what":"Estructuras de control secuenciales","title":"Estructuras de control del código","text":"Las estructuras secuenciales están compuestas por un número definido de acciones que se ubican en un orden específico y se suceden una tras otra. Los ejemplos que hemos discutido anteriormente están conformados por este tipo de estructura.","code":""},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-de-control-condicionales","dir":"Articles","previous_headings":"","what":"Estructuras de control condicionales","title":"Estructuras de control del código","text":"En algunas partes de un algoritmo puede ser útil detenerse hacer una pregunta porque se llegó una situación en la que puede haber una o más opciones disponibles para continuar. Dependiendo de la respuesta la pregunta, que siempre deberá ser VERDADERO (TRUE) o FALSO (FALSE), el algoritmo seguirá ciertas acciones e ignorará otras. Estas preguntas y respuestas representan procesos de toma de decisión que conducen diferentes caminos dentro del algoritmo, permitiéndonos que la solución para el problema en cuestión sea flexible y se adapte distintas situaciones. Este tipo de estructuras de control de las acciones reciben el nombre de condicionales (o estructuras de selección) y pueden ser simples, dobles y múltiples.","code":""},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-condicionales-simples","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales simples","title":"Estructuras de control del código","text":"Postulan una evaluación lógica y, si su resultado es TRUE, se procede ejecutar las acciones encerradas por esta estructura. se expresan en R con la siguiente sintaxis: La palabra indica el comando de evaluación lógica, condición indica la evaluación realizar y entre llaves se detallas las instrucciones que se realizarán sólo si se cumple la condición, es decir, si la evaluación resulta en TRUE. Si la condición se verifica, se ejecuta ninguna acción y el programa sigue su estructura secuencial con el código que prosigue la última llave. Karel nos va ayudar ejemplificar esto. La siguiente tabla muestra las evaluaciones lógicas que la robot puede realizar acerca de su mundo. Por ejemplo, si ejecutamos la función frente_abierto(), obtendremos el valor TRUE si efectivamente hay una pared enfrente de Karel o el valor FALSE si hay una pared. Podemos usar una estructura condicional para modificar la función llenar_agujero() que creamos anteriormente para que Karel coloque un coso sólo si había ya uno presente en el agujero: Notar que si bien el uso de sangrías en el código es opcional, decidimos emplearlo para facilitar su lectura. Mantener la prolijidad en nuestros programas es esencial.","code":"if (condición) {     ...código para ejecutar acciones... } # ------------ Definición de funciones auxiliares-----------  llenar_agujero <- function() {   girar_derecha()   avanzar()   if (no_hay_cosos()) {     poner_coso()   }   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal -------------------  generar_mundo(\"mundo002\") avanzar() llenar_agujero() ejecutar_acciones()"},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-condicionales-dobles","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales dobles","title":"Estructuras de control del código","text":"Este tipo de estructura añade una acción ejecutarse en el caso de que la condición evaluada se verifique (es decir, devuelve el valor FALSE). La sintaxis es: Dentro del primer bloque de llaves se escriben las acciones que se realizan si se cumple la condición, mientras que en el segundo, luego de la expresión else, se incluyen las que se realizan si se verifica la misma. Imaginemos que queremos crear un algoritmo para revertir el estado de una celda, es decir, que Karel ponga un coso si hay o lo quite si es que hay:  Para esto podemos usar una estructura condicional doble:  Dado que repetimos 3 veces, exactamente de la misma forma, el proceso de controlar si hay o un coso para decidir quitarlo o poner uno, otra vez podemos recurrir al principio de la descomposición algorítmica y definir una función que se encargue de ellos, se forma que la acción de invertir el estado de una celda se haga de manera más sencilla. Nuestro archivo de código quedaría así:","code":"if (condición) {     ...código para ejecutar acciones... } else {     ...código para ejecutar acciones... } generar_mundo(\"mundo001\") if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } avanzar() if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } avanzar() if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } ejecutar_acciones() # ------------ Definición de funciones auxiliares-----------  invertir <- function() {   if (hay_cosos()) {     juntar_coso()   } else {     poner_coso()   } }  # ------------------- Programa principal -------------------  generar_mundo(\"mundo001\") invertir() avanzar() invertir() avanzar() invertir() ejecutar_acciones()"},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-condicionales-múltiples-o-anidadas","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales múltiples o anidadas","title":"Estructuras de control del código","text":"Permiten combinar varias estructuras condicionales para establecer controles más complejos sobre el flujo de las acciones, representando una toma de decisión múltiple. Podemos ejemplificar la sintaxis de la siguiente forma: En la estructura anterior, hay una primera evaluación lógica en la cual si el resultado es VERDADERO, se ejecuta el primer conjunto de acciones y nada más. En cambio, si su resultado es FALSO, se procede realizar una segunda evaluación lógica, que da lugar la ejecución del segundo o del tercer bloque de acciones, dependiendo de que su resultado sea VERDADERO o FALSO, respectivamente.","code":"if (condición 1) {     ...Primer conjunto de acciones... } else if (condición 2) {     ...Segundo conjunto de acciones... } else {     ...Tercer conjunto de acciones... }"},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas","dir":"Articles","previous_headings":"","what":"Estructuras de control iterativas","title":"Estructuras de control del código","text":"Las estructuras de control iterativas son útiles cuando la solución de un problema requiere que se ejecute repetidamente un determinado conjunto de acciones. El número de veces que se debe repetir dicha secuencia de acciones puede ser fijo o variable dependiendo de algún dato en el algoritmo.","code":""},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas-con-un-número-fijo-de-iteraciones","dir":"Articles","previous_headings":"Estructuras de control iterativas","what":"Estructuras de control iterativas con un número fijo de iteraciones","title":"Estructuras de control del código","text":"Se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de acciones. Por ejemplo, consideremos el siguiente problema donde hay agujeros distribuidos equiespaciadamente en las avenidas pares.  Tenemos que escribir un programa para que Karel llene los 5 agujeros. Podríamos planear algo como: Es evidente que tiene sentido escribir exactamente lo mismo 5 veces. Por eso vamos hacer uso de una estructura iterativa: La letra recibe el nombre de variable de iteración. Podríamos haber elegido otra letra u otra palabra en su lugar, pero emplear es bastante común. En este ejemplo, su única función es guiar la serie de pasos. El bloque de instrucciones se repite tantas veces como tarde en llegar 5 partiendo desde 1. De manera general, la sintaxis para este tipo de estructuras es:","code":"# ------------------- Programa principal -------------------  generar_mundo(\"mundo003\") avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar() ejecutar_acciones() generar_mundo(\"mundo003\") for (i in 1:5) {   avanzar()   llenar_agujero()   avanzar() } ejecutar_acciones() for (<variable> in <valor1>:<valor2>) {     ...Acción/es... }"},{"path":"/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas-con-un-número-indeterminado-de-iteraciones","dir":"Articles","previous_headings":"Estructuras de control iterativas","what":"Estructuras de control iterativas con un número indeterminado de iteraciones","title":"Estructuras de control del código","text":"En otras circunstancias se puede necesitar repetir un bloque de acciones sin conocer con exactitud cuántas veces, si que esto depende de algún otro aspecto del ALGORITMO. Las iteraciones pueden continuar mientras que se verifique alguna condición. En este tipo de estructuras, el conjunto de instrucciones se repite mientras que se siga evaluando como VERDADERO una condición declarada al inicio del bloque. Cuando la condición ya se cumple, el proceso deja de ejecutarse. La sintaxis es: Observaciones: La evaluación de la condición se lleva cabo antes de cada iteración, incluyendo la primera. Si la condición es FALSO inicialmente, entonces las acciones en el cuerpo de la estructura se ejecutan nunca. La evaluación de la condición sólo se lleva cabo al inicio de cada iteración. Si la condición se vuelve FALSO en algún punto durante la ejecución de un bloque, el programa lo nota hasta que se termine de ejecutar el bloque y la condición sea evaluada antes de comenzar la próxima iteración. Por ejemplo, sería interesante escribir un programa para llenar agujeros como el anterior, pero que sirva de manera general para otras situaciones donde puede haber cualquier cantidad de agujeros en la calle, como estas:  En vez de usar un en el cual hay que especificar la cantidad de veces que el proceso debe repetirse, podemos usar un para que Karel siga rellenando agujeros mientras que haya una pared enfrente suyo, lo cual indicaría que llegó al final y debe detenerse. Hay que tener mucho cuidado la hora de escribir este tipo de estructura, para asegurarse de producir un loop infinito, es decir, un proceso iterativo que nunca finaliza. Esto ocurriría, por ejemplo, si estando en el mundo anterior, le pedimos Karel que gire mientras que haya cosas donde está parada: Algunos ejemplos presentados en este tutorial fueron adaptados de Karel robot learns Java (Eric Roberts, 2005).","code":"while (<condición>) {     ...Acción/es a repetir... } # ------------------- Programa principal ------------------- generar_mundo(\"mundo003\") while (frente_abierto()) {   avanzar()   llenar_agujero()   avanzar() } ejecutar_acciones() # No correr esto! (o sí, para ver cómo no anda!) generar_mundo(\"mundo003\") while (no_hay_cosos()) {     girar_izquierda() } ejecutar_acciones()"},{"path":"/articles/e_examples_es.html","id":"otra-vez-a-reparar-la-calle","dir":"Articles","previous_headings":"","what":"Otra vez a reparar la calle","title":"Varios problemas de ejemplo","text":"En la sección anterior propusimos el siguiente programa para resolver el problema de llenar los agujeros de la calle: Este programa sirve para mundos con calles de cualquier largo, sin embargo serviría si los agujeros estuviesen equiespaciados como asumimos inicialmente. Sería mejor tener un programa más general que funcione bajo estas condiciones: El mundo puede tener calles de cualquier largo. Los agujeros pueden estar en cualquier posición lo largo de la calle, sin restricciones en cuanto la cantidad o su espaciado. Algunos agujeros podrían estar ya reparados, de modo que Karel debe poner un coso en ellos. Un ejemplo de este tipo de mundo es este:  Para solucionar este problema, en vez de comenzar cada iteración con un avance, deberíamos primero chequear si donde Karel está parada hay un agujero, si es así llenarlo en el caso de que estuviese reparado y luego avanzar. Por lo tanto se debe modificar el bloque que se itera: Sin embargo, este programa tiene una falla, porque si bien anda en esta situación…  …funciona en esta:  Karel se detiene sin llenar el último agujero. De hecho, Karel ni siquiera desciende para ver si hay que llenarlo o . El problema está en que apenas Karel rellena el agujero de la avenida 6, ejecuta la acción de avanzar, quedando enfrente de una pared, lo cual hace que el loop se detenga antes de evaluar esa última posición. Este es un error lógico bastante frecuente cuando se trabaja con estructuras iterativas, pero su solución es sencilla. Lo único que tenemos que hacer es agregar un chequeo adicional después de haber finalizado el :","code":"# ------------ Definición de funciones auxiliares-----------  # Función: llenar_agujero llenar_agujero <- function() {   girar_derecha()   avanzar()   if (no_hay_cosos()) {     poner_coso()   }   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal -------------------  generar_mundo(\"mundo003\") while (frente_abierto()) {   avanzar()   llenar_agujero()   avanzar() } ejecutar_acciones() generar_mundo(\"mundo006\") # ------------------- Programa principal -------------------  generar_mundo(\"mundo106\") while (frente_abierto()) {   if (derecha_abierto()) {     llenar_agujero()   }     avanzar() } ejecutar_acciones() # ------------------- Programa principal -------------------  generar_mundo(\"mundo007\") while (frente_abierto()) {   if (derecha_abierto()) {     llenar_agujero()   }     avanzar() } ejecutar_acciones() # ------------------- Programa principal -------------------  generar_mundo(\"mundo007\") while (frente_abierto()) {   if (derecha_abierto()) {     llenar_agujero()   }     avanzar() } if (derecha_abierto()) {     llenar_agujero() } ejecutar_acciones()"},{"path":"/articles/e_examples_es.html","id":"crear-otras-funciones-que-hagan-de-kareal-aún-más-poderosa","dir":"Articles","previous_headings":"","what":"Crear otras funciones que hagan de Kareal aún más poderosa","title":"Varios problemas de ejemplo","text":"Karel ya sabe girar, avanzar, poner y juntar cosos. Sin embargo, podemos imaginar que para desempeñarse en su mundo, seguramente hay algunas actividades que debe repetir menudo. Por ejemplo, avanzar derechito hasta que se encuentre con una pared, juntar todos los cosos que se pueda encontrar lo largo de una calle o avenida o vaciar su mochila poniendo cosos en un lugar hasta que ya le quede ninguno. Vamos crear funciones que se encarguen de estas tareas, de modo que Karel pueda implementarlas en cualquier momento. Avanzar hasta encontrarse con una pared Recolectar una línea de cosos Poner todos los cosos que tiene en la mochila en un lugar","code":"# Función: avanzar_hasta_pared() # Descripción: permite que Karel avance hasta que encuentre una pared # Condición inicial: ninguna # Condición final: Karel queda enfrentada a una pared avanzar_hasta_pared <- function() {   while (frente_abierto()) {     avanzar()   } } # Función: recolectar_linea() # Descripción: permite recolectar una línea consecutiva de cosos. La línea # termina en la primera celda que no tiene cosos. # Condición inicial: ninguna # Condición final: Karel está en el final de la línea con la misma dirección que # al inicio recolectar_linea <- function() {   while (hay_cosos()) {     juntar_coso()     if (frente_abierto()) {       avanzar()     }   } } # Función: colocar_todo() # Descripción: Karel coloca todos los cosos que tiene en su mochila en su # posición actual # Condición inicial: ninguna # Condición final: ninguna colocar_todo <- function() {   while (karel_tiene_cosos()) {     poner_coso()   } }"},{"path":"/articles/e_examples_es.html","id":"recoger-columnas-de-cosos","dir":"Articles","previous_headings":"","what":"Recoger columnas de cosos","title":"Varios problemas de ejemplo","text":"En este ejemplo, hay paredes en el mundo de Karel pero en algunas avenidas hay columnas de cosos de cualquier altura, mientras que otras avenidas están vacías. El trabajo de Karel es recolectarlas todas, dejarlas en la posición de abajo la derecha como muestra el diagrama y volver su posición inicial:  Como ya hemos dicho, un buen consejo para encarar cualquier problema es tratar de descomponerlo en partes más pequeñas. Siguiendo esta idea, podemos imaginarnos que el programa principal puede estar compuesto por tres partes: recolectar todos los cosos y guardarlos en su mochila que inicialmente estará vacía, depositarlos en la esquina y volver la posición inicial. Algo como esto: Así como está, es muy sencillo entender qué es lo que hay que hacer. Además, hace uso de una función que ya tenemos definida de antes, colocar_todo(). Lo único que falta, que es poco, es escribir los otros dos subalgoritmos, que su vez pueden descomponerse en otros problemas menores. En primer instancia, hay que recolectar todas las columnas de cosos, sin saber cuántas pueden ser, esto nos hace pensar en que será necesario un . Tenemos que recolectar columna por columna hasta que nos encontremos con la pared: Notar que después del hemos repetido recolectar_una_columna(), por la razón expuesta en el ejemplo anterior. Además, le estamos diciendo que recolecte la columna sin haber chequeado si había una… ¿qué pasa si hay ninguna? Respondé esta pregunta cuando leas el programa completo más abajo, pero te aseguramos que está bien hacerlo así. Claro que entonces necesitamos crear esta nueva función recolectar_una_columna(), que tiene que encargarse de que Karel: Gire para mirar hacia el norte. Recolecte todos los cosos deteniéndose cuando ya haya más (¿te suena este problema?. Se dé vuelta para emprender el descenso. Baje hasta la pared que representa al piso (¿te suena este problema?). Vuelva girar para estar lista para avanzar la siguiente columna. Entonces, la función tiene que ser algo así: Aparecieron por ahí dos funciones que definimos en el ejercicio anterior, que como anticipamos son actividades bastante comunes que nos viene muy bien tenerlas ya programadas. El programa completo se muestra continuación. Recordar que en R necesitamos ejecutar primero las funciones que hemos inventado y luego el programa principal que las utiliza.","code":"generar_mundo(\"mundo008\") recolectar_todo() colocar_todo() volver_inicio() ejecutar_acciones() recolectar_todo <- function() {   while (frente_abierto()) {     recolectar_una_columna()     avanzar()   }   recolectar_una_columna() } recolectar_una_columna <- function() {   girar_izquierda()   recolectar_linea()   darse_vuelta()   avanzar_hasta_pared()   girar_izquierda() } # ------------ Definición de otras funciones auxiliares-----------  # Función: recolectar_todo() # Descripción: permite recolectar todos los cosos de cada columna moviéndose a # lo largo de la primera calle. # Condición inicial: Karel está mirando al este en la posición (1, 1) # Condición final: Karel está mirando al este en la posición del extremo derecho # de la primera fila recolectar_todo <- function() {   while (frente_abierto()) {     recolectar_una_columna()     avanzar()   }   recolectar_una_columna() }  # Función: recolectar_una_columna() # Descripción: permite recolectar todos los cosos en una única columna # Condición inicial: Karel debe estar en la base de la columna mirando al este # Condición final: Karel está en la misma posición y dirección que al inicio recolectar_una_columna <- function() {   girar_izquierda()   recolectar_linea()   darse_vuelta()   avanzar_hasta_pared()   girar_izquierda() }  # Función: volver_inicio() # Descripción: permite que Karel regrese a la posición (1, 1) # Condición inicial: Karel mira al este en algún lugar de la primera fila # Condición final: Karel está en la posición (1, 1) mirando al este volver_inicio <- function() {   darse_vuelta()   avanzar_hasta_pared()   darse_vuelta() }  # ------------------- Programa principal ------------------- generar_mundo(\"mundo008\") recolectar_todo() colocar_todo() volver_inicio() ejecutar_acciones()"},{"path":"/articles/e_examples_es.html","id":"el-laberinto","dir":"Articles","previous_headings":"","what":"El laberinto","title":"Varios problemas de ejemplo","text":"Ahora nos vamos imaginar que Karel está en un laberinto como el siguiente, donde el coso indica la salida:  Tenemos que crear un programa para que Karel pueda llegar hasta ahí, sin embargo tiene que ser general para que sirva para este y cualquier otro laberinto. Hay una estrategia para resolver cualquier laberinto: si cuando entrás tocás con tu mano la pared tu derecha y caminás sin dejar de tocarla nunca, eventualmente llegarás la salida. Esto se conoce como la regla de la mano derecha y se traduce en doblar siempre la derecha, en toda selección de caminos que se te presente (por supuesto, también serviría si se hiciera siempre con la izquierda). El breve programa que se presenta continuación implementa el algoritmo de la mano derecha. Muchas veces, los programas que resuelven problemas muy interesantes son ni largos ni rebuscados. Miralo con atención hasta que estés convencido de entender la lógica de este algoritmo:","code":"# ------------------- Programa principal -------------------  generar_mundo(\"mundo009\") while (no_hay_cosos()) {   girar_derecha()   while (frente_cerrado()) {     girar_izquierda()   }   avanzar() } ejecutar_acciones()"},{"path":"/articles/e_examples_es.html","id":"más-problemas","dir":"Articles","previous_headings":"","what":"Más problemas","title":"Varios problemas de ejemplo","text":"continuación se dejan propuestos algunos ejercicios para seguir repasando lo aprendido junto Karel.","code":""},{"path":"/articles/e_examples_es.html","id":"problema-1-juntar-el-periódico","dir":"Articles","previous_headings":"Más problemas","what":"Problema 1: juntar el periódico","title":"Varios problemas de ejemplo","text":"Para calentar motores, comenzaremos con un problema simple. Imaginemos que Karel está en su casa, la cual es la región cuadrada en el centro del siguiente diagrama:  Karel debe salir de su casa para recoger el periódico (representado, obviamente, por un coso) y volver su posición inicial, donde colocará el periódico para ponerse leer. Vamos asumir que la casa de Karel (su tamaño, la ubicación de la puerta y del periódico) sufren cambios, es decir, hay que generalizar este problema para otras configuraciones posibles del esquema. Escribir el programa en R, de las siguientes formas: En primer lugar, se debe resolver este problema usando solamente las cuatro acciones básicas de Karel (avanzar, girar la izquierda, poner y juntar cosos). En segundo lugar, resolver el problema empleando el principio de la descomposición algorítmica. Para esto, un subalgoritmo que se encargue de que Karel salga de su casa y otro para que Karel ingrese y regrese la posición inicial. Usarlos en el algoritmo principal. Además, se puede hacer uso de los superpoderes de Karel (girar la derecha y darse vuelta), cuyas funciones en R están disponibles si previamente corremos cargar_super_karel(). Utilizar el mundo: \"mundo011\".","code":""},{"path":"/articles/e_examples_es.html","id":"problema-2-dar-vueltas-a-la-casa","dir":"Articles","previous_headings":"Más problemas","what":"Problema 2: dar vueltas a la casa","title":"Varios problemas de ejemplo","text":"Ahora vamos suponer que Karel tiene ejercitarse un poco y para eso va salir de su casa y dar exactamente tres vueltas alrededor de la misma, en sentido de las agujas del reloj. Escribir el algoritmo y el programa que permiten hacer esto, teniendo en cuenta la estructura del mundo provisto en el problema anterior (\"mundo011\"). Emplear los subalgoritmos creados en el problema 1.b, así como cualquier otro que consideres necesario crear. Karel debe finalizar con la misma posición y dirección que tenía al comienzo.","code":""},{"path":"/articles/e_examples_es.html","id":"problema-3-crear-línea-de-cosos","dir":"Articles","previous_headings":"Más problemas","what":"Problema 3: crear línea de cosos","title":"Varios problemas de ejemplo","text":"Escribir una función para que Karel coloque una línea de cosos comenzando en su posición actual y avanzando hasta que encuentre una pared enfrente. Por ejemplo: el resultado de ejecutar esta función en un mundo vacío sería este:  La función debe servir para mundos de cualquier tamaño. Utilizar los mundos: \"mundo012\", \"mundo013\" y \"mundo014\".","code":""},{"path":"/articles/e_examples_es.html","id":"problema-4-saltar-los-palotes","dir":"Articles","previous_headings":"Más problemas","what":"Problema 4: saltar los palotes","title":"Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda saltar palotes como en el siguiente esquema:  Algunas consideraciones: Karel “salta” los palotes bordeándolos, de uno por vez. Karel comienza en la posición (1, 1) y debe terminar en la (9, 1). La solución debe funcionar en mundos que pueden tener distinta cantidad de palotes y de distintos largos, pero siempre con 9 avenidas de ancho. Usar los mundos: \"mundo015\" y \"mundo016\".","code":""},{"path":"/articles/e_examples_es.html","id":"problema-5-limpiar-el-mundo","dir":"Articles","previous_headings":"Más problemas","what":"Problema 5: limpiar el mundo","title":"Varios problemas de ejemplo","text":"En este problema tenemos que ayudar Karel limpiar su mundo, dado que hay cosos dando vuelta por todos lados. Se debe asumir que: Karel comienza en la posición (1, 1). Inicialmente, cada posición en el mundo puede estar vacía o tener cuanto mucho un coso y al finalizar, debe quedar ningún coso en el mundo. Karel puede tener cualquier posición y dirección al finalizar. Por ejemplo, al correr tu programa en el siguiente mundo, este sería el resultado esperado:  Utilizar los mundos: \"mundo017\" y \"mundo018\".","code":""},{"path":"/articles/e_examples_es.html","id":"problema-6-poner-cosos-en-los-vértices-del-rombo","dir":"Articles","previous_headings":"Más problemas","what":"Problema 6: poner cosos en los vértices del rombo","title":"Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda colocar cosos en los vértices del rombo en en el cual está encerrada, como se muestra continuación:  El programa debe funcionar en mundos donde el tamaño del rombo puede ser distinto, pero se puede asumir que Karel siempre inicia posicionada en el vértice que da al oeste, mirando hacia el este. Utilizar los mundos mundo019 y mundo020.","code":""},{"path":"/articles/e_examples_es.html","id":"problema-7-duplicar-el-número-de-cosos","dir":"Articles","previous_headings":"Más problemas","what":"Problema 7: duplicar el número de cosos","title":"Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda duplicar el número de cosos que se encuentran en una posición determinada. Por ejemplo:  Asumir que: el mundo siempre luce como en el diagrama anterior (mismo tamaño y sin paredes). los cosos que deben ser duplicados están siempre en la posición (3, 3) y allí mismo deberá estar el doble de cosos al terminar. la cantidad inicial de cosos en la posición (3, 3) puede ser cualquiera, habiendo siempre al menos uno. Karel tiene infinitos cosos en su mochila. El programa principal debe ser: Es decir, deberán escribir una función, llamada duplicar_cosos() que se encargue de realizar esta tarea, el cual su vez puede estar descompuesto en otros subalgoritmos. Utilizar el mundo mundo021.","code":"# Programa principal generar_mundo(\"mundo021\") avanzar() duplicar_cosos() avanzar() ejecutar_acciones()"},{"path":"/articles/e_examples_es.html","id":"problema-8-reparar-columnas","dir":"Articles","previous_headings":"Más problemas","what":"Problema 8: reparar columnas","title":"Varios problemas de ejemplo","text":"Karel fue contratada para restaurar las columnas de un antiguo paredón y para esto debe colocarles las piedras que les faltan, representadas obviamente por cosos. Es decir, tiene que lograr esto:  Escribir un programa que funcione en el esquema anterior, pero que además sea lo suficientemente general como para que funcione en otros paredones (mundos) que cumplan con las características mencionadas continuación: Karel inicialmente se encuentra en la intersección de Avenida 1 y Calle 1, mirando al este, con una cantidad infinita de cosos en su mochila. Las columnas están siempre una distancia de 4 posiciones, en la Avenida 1, 5, 9, etc. El final de la secuencia de columnas está determinado por la pared (el borde del mundo) inmediatamente después de la última columna. En el diagrama de ejemplo, termina luego de la Avenida 13, pero podría terminar luego de la 5, 9, 13, 17, etc. El borde superior de la columna está determinado por una pared horizontal, pero Karel debe asumir que la altura de las columnas sea siempre de 5 como en el ejemplo, ni tampoco que todas las columnas tengan la misma altura. Algunas partes de las columnas tienen un coso, representando piedras que necesitan reparación, Karel debe colocar un segundo coso sobre ellas. La posición y dirección final de Karel importan. Utilizar los mundos mundo022, mundo023 y mundo024.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Marcos Prunello. Author, maintainer, copyright holder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Prunello M (2023). karel: Learning programming Karel robot. R package version 0.1.1.9000, https://mpru.github.io/karel/.","code":"@Manual{,   title = {karel: Learning programming with Karel the robot},   author = {Marcos Prunello},   year = {2023},   note = {R package version 0.1.1.9000},   url = {https://mpru.github.io/karel/}, }"},{"path":[]},{"path":"/index.html","id":"quién-es-karel--who-is-karel","dir":"","previous_headings":"","what":"¿Quién es Karel? / Who is Karel?","title":"Learning programming with Karel the robot","text":"Esta paquete implementa en R Karel robot, un lenguaje de programación creado por el Dr. R. E. Pattis en la Universidad de Stanford en 1981. Karel es una herramienta útil para enseñar conceptos introductorios sobre programación, como descomposición algorítmica, declaraciones condicionales, bucles, etc., de una manera interactiva y divertida, mediante la escritura de programas para que Karel el robot logre ciertas tareas en el mundo en el que vive. Originalmente basado en Pascal, Karel fue implementado en muchos lenguajes lo largo de estas décadas, incluyendo Java, C++, Ruby y Python. Este es el primer paquete que implementa Karel en R. R implementation Karel robot, programming language created Dr. R. E. Pattis Stanford University 1981. Karel useful tool teach introductory concepts general programming, algorithmic decomposition, conditional statements, loops, etc., interactive fun way, writing programs make Karel robot achieve certaing tasks world lives . Originally based Pascal, Karel implemented many languages decades, including Java C++, Ruby Python. first package implementing Karel R.","code":""},{"path":"/index.html","id":"instalación--installation","dir":"","previous_headings":"","what":"Instalación / Installation","title":"Learning programming with Karel the robot","text":"Podés instalar karel desde CRAN / can install karel CRAN: También podés instalar la versión en desarrollo desde GitHub / can also install development version GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"mpru/karel\")"},{"path":"/index.html","id":"ejemplos--examples","dir":"","previous_headings":"","what":"Ejemplos / Examples","title":"Learning programming with Karel the robot","text":"Podés programar Karel para que realice tareas como las siguientes / can program Karel perform tasks :   Visitá los artículos para ver cómo lograrlo y solucionar muchos casos más / Visit articles learn solve problems. Web: https://mpru.github.io/karel/","code":""},{"path":"/reference/acciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Acciones que Karel puede realizar — acciones","title":"Acciones que Karel puede realizar — acciones","text":"avanzar(), girar_izquierda(), juntar_coso() y poner_coso() son las cuatro actividades básicas que Karel sabe realizar. Si se habilitan los superpoderes de Karel con cargar_super_karel(), entonces también puede girar_derecha() y darse_vuelta().","code":""},{"path":"/reference/acciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Acciones que Karel puede realizar — acciones","text":"","code":"avanzar()  girar_izquierda()  poner_coso()  juntar_coso()  girar_derecha()  darse_vuelta()"},{"path":"/reference/acciones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Acciones que Karel puede realizar — acciones","text":"Estas funciones devuelven nada, pero realizan cambios en el mundo   de Karel que se ven cuando se ejecutan todas las acciones con  ejecutar_acciones().","code":""},{"path":[]},{"path":"/reference/acciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Acciones que Karel puede realizar — acciones","text":"","code":"generar_mundo(\"mundo001\")  avanzar() juntar_coso() girar_izquierda() poner_coso() ejecutar_acciones()"},{"path":"/reference/actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Available actions for Karel — actions","title":"Available actions for Karel — actions","text":"move(), turn_left(), pick_beeper() y put_beeper() four basic activities Karel can perform. turn Karel's superpowers load_super_karel(), can also turn_right() y turn_around().","code":""},{"path":"/reference/actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Available actions for Karel — actions","text":"","code":"move()  turn_left()  put_beeper()  pick_beeper()  turn_right()  turn_around()"},{"path":"/reference/actions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Available actions for Karel — actions","text":"functions return anything, make changes Karel's   world visible actions run  run_actions().","code":""},{"path":[]},{"path":"/reference/actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Available actions for Karel — actions","text":"","code":"generate_world(\"mundo001\")  move() pick_beeper() turn_left() put_beeper() run_actions()"},{"path":"/reference/cargar_super_karel.html","id":null,"dir":"Reference","previous_headings":"","what":"Habilitar los superpoderes de Karel — cargar_super_karel","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"Luego de correr cargar_super_karel(), Karel también puede girar la derecha y darse vuelta, través de las acciones girar_derecha() y darse_vuelta(). Si se cargan los superpoderes, estas dos funciones están disponibles.","code":""},{"path":"/reference/cargar_super_karel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"","code":"cargar_super_karel()"},{"path":"/reference/cargar_super_karel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"devuelve ningún valor, pero adjuntan al Global Environment las funciones girar_derecha() y darse_vuelta().","code":""},{"path":[]},{"path":"/reference/cargar_super_karel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"","code":"generar_mundo(\"mundo001\")  cargar_super_karel() darse_vuelta() girar_derecha() ejecutar_acciones()"},{"path":"/reference/check_user_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Check user's own world — check_user_world","title":"Check user's own world — check_user_world","text":"function analyzes world provided user satisfies requirements.","code":""},{"path":"/reference/check_user_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check user's own world — check_user_world","text":"","code":"check_user_world(world)"},{"path":"/reference/check_user_world.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check user's own world — check_user_world","text":"world world provided user. list. See details generar_mundo.","code":""},{"path":"/reference/check_user_world.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check user's own world — check_user_world","text":"misespecification found, function produces stop   provides descriptive error message.","code":""},{"path":"/reference/check_user_world.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check user's own world — check_user_world","text":"function called generar_mundo.","code":""},{"path":"/reference/check_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the walls user's provided world — check_walls","title":"Check the walls user's provided world — check_walls","text":"helper function check ver_walls hor_walls. called check_user_world twice.","code":""},{"path":"/reference/check_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the walls user's provided world — check_walls","text":"","code":"check_walls(dataset, name, nx, ny)"},{"path":"/reference/check_walls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the walls user's provided world — check_walls","text":"dataset Either hor_walls ver_walls name Character string: \"hor_walls\" \"ver_walls\" nx, ny Size world","code":""},{"path":"/reference/check_walls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the walls user's provided world — check_walls","text":"misespecification found, function produces stop   provides descriptive error message.","code":""},{"path":"/reference/condiciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Condiciones que Karel puede verificar — condiciones","title":"Condiciones que Karel puede verificar — condiciones","text":"Este conjunto de funciones devuelven un valor lógico TRUE o FALSE según la evaluación que Karel puede hacer de su mundo.","code":""},{"path":"/reference/condiciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condiciones que Karel puede verificar — condiciones","text":"","code":"frente_abierto()  frente_cerrado()  izquierda_abierto()  izquierda_cerrado()  derecha_abierto()  derecha_cerrado()  hay_cosos()  no_hay_cosos()  karel_tiene_cosos()  karel_no_tiene_cosos()  mira_al_este()  mira_al_norte()  mira_al_oeste()  mira_al_sur()"},{"path":"/reference/condiciones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Condiciones que Karel puede verificar — condiciones","text":"Valor lógico TRUE o FALSE.","code":""},{"path":"/reference/condiciones.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Condiciones que Karel puede verificar — condiciones","text":"Las funciones frente_abierto(), frente_cerrado(),   izquierda_abierto(), izquierda_cerrado(),   derecha_abierto() y derecha_cerrado() analizan si hay paredes   al frente, la izquierda o la derecha de Karel. Las funciones   hay_cosos() y no_hay_cosos() analizan si hay cosos en   la posición actual de Karel. Las funciones karel_tiene_cosos() y   karel_no_tiene_cosos() analizan si Karel tiene cosos en su   mochila (visibles en la representación gráfica). Las funciones   mira_al_este(), mira_al_oeste(), mira_al_norte() y   mira_al_sur() analizan la dirección hacia la cual Karel está   mirando.","code":""},{"path":[]},{"path":"/reference/condiciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Condiciones que Karel puede verificar — condiciones","text":"","code":"generar_mundo(\"mundo001\")  frente_abierto() #> [1] TRUE frente_cerrado() #> [1] FALSE izquierda_abierto() #> [1] TRUE izquierda_cerrado() #> [1] FALSE derecha_abierto() #> [1] FALSE derecha_cerrado() #> [1] TRUE hay_cosos() #> [1] FALSE no_hay_cosos() #> [1] TRUE karel_tiene_cosos() #> [1] TRUE karel_no_tiene_cosos() #> [1] FALSE mira_al_este() #> [1] TRUE mira_al_oeste() #> [1] FALSE mira_al_norte() #> [1] FALSE mira_al_sur() #> [1] FALSE"},{"path":"/reference/conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditions that Karel can test — conditions","title":"Conditions that Karel can test — conditions","text":"group functions return logical value TRUE o FALSE according Karel's evaluation world.","code":""},{"path":"/reference/conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditions that Karel can test — conditions","text":"","code":"front_is_clear()  front_is_blocked()  left_is_clear()  left_is_blocked()  right_is_clear()  right_is_blocked()  beepers_present()  no_beepers_present()  karel_has_beepers()  karel_has_no_beepers()  facing_east()  facing_west()  facing_north()  facing_south()"},{"path":"/reference/conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditions that Karel can test — conditions","text":"Logical value TRUE FALSE.","code":""},{"path":"/reference/conditions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conditions that Karel can test — conditions","text":"functions front_is_clear(), front_is_blocked(), left_is_clear(), left_is_blocked(), right_is_clear() y right_is_blocked() test wall front Karel, left right, respectively. functions beepers_present() y no_beepers_present() test beepers Karel's current position. functions karel_has_beepers() y karel_has_no_beepers() test Karel got  beepers bag (visible plot). functions facing_east(), facing_west(), facing_north() y facing_south() test direction Karel facing right now.","code":""},{"path":[]},{"path":"/reference/conditions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditions that Karel can test — conditions","text":"","code":"generate_world(\"mundo001\")  front_is_clear() #> [1] TRUE front_is_blocked() #> [1] FALSE left_is_clear() #> [1] TRUE left_is_blocked() #> [1] FALSE right_is_clear() #> [1] FALSE right_is_blocked() #> [1] TRUE beepers_present() #> [1] FALSE no_beepers_present() #> [1] TRUE karel_has_beepers() #> [1] TRUE karel_has_no_beepers() #> [1] FALSE facing_east() #> [1] TRUE facing_west() #> [1] FALSE facing_north() #> [1] FALSE facing_south() #> [1] FALSE"},{"path":"/reference/create_beepers.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dataset about beepers — create_beepers","title":"Create dataset about beepers — create_beepers","text":"Given elements provided world, function generates dataset info beepers present world. function called generar_mundo().","code":""},{"path":"/reference/create_beepers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dataset about beepers — create_beepers","text":"","code":"create_beepers(nx = NULL, pos_x = NULL, pos_y = NULL, n = NULL, moment = 1)"},{"path":"/reference/create_beepers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create dataset about beepers — create_beepers","text":"nx horizontal size world pos_x, pos_y vectors coordinates cells non-zero amount beepers n number beepers cell indicated coordinates pos_x pos_y moment time","code":""},{"path":"/reference/create_beepers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create dataset about beepers — create_beepers","text":"tibble many rows cells beepers world 5   columns: x y coordinates cell, cell number cell counting cell number 1 cell bottom   left corner going upwards row (meaning cell number 2   cell coordinates x=2 y=1), n number beepers   cell moment moment state world   corresponds .","code":""},{"path":"/reference/draw_karel_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"Karel drawn 6 squares (body, feet, eyes mouth) using geom_rect(), need arguments xmin, xmax, ymin ymax . function takes Karel's current position (x, y) direction (1 east, 2 north, 3 west, 4 south) generates corresponding values xmin, xmax, ymin ymax.","code":""},{"path":"/reference/draw_karel_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"","code":"draw_karel_df(x, y, direction, moment)"},{"path":"/reference/draw_karel_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"6x7 tibble. First row body, 2nd left foot,   right foot, left eye, right eye finally mouth. Columns xmin,   xmax, ymin, ymax, moment (time), color (fill) transparency   value (alpha)","code":""},{"path":"/reference/draw_karel_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"function called repeatedly position Karel time.","code":""},{"path":"/reference/ejecutar_acciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar acciones — ejecutar_acciones","title":"Ejecutar acciones — ejecutar_acciones","text":"Esta función produce la animación que muestra todas las acciones realizadas por Karel desde que su mundo fue generado con generar_mundo.","code":""},{"path":"/reference/ejecutar_acciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ejecutar acciones — ejecutar_acciones","text":"","code":"ejecutar_acciones(repetir = TRUE)"},{"path":"/reference/ejecutar_acciones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ejecutar acciones — ejecutar_acciones","text":"repetir Valor lógico TRUE o FALSE que indica si la animación debe repetirse una y otra vez luego de finalizada (por defecto: TRUE).","code":""},{"path":"/reference/ejecutar_acciones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ejecutar acciones — ejecutar_acciones","text":"Produce una animación con gganimate.","code":""},{"path":[]},{"path":"/reference/ejecutar_acciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ejecutar acciones — ejecutar_acciones","text":"","code":"generar_mundo(\"mundo001\")  avanzar() juntar_coso() girar_izquierda() poner_coso() ejecutar_acciones()"},{"path":"/reference/generar_mundo.html","id":null,"dir":"Reference","previous_headings":"","what":"Generar el mundo de Karel — generar_mundo","title":"Generar el mundo de Karel — generar_mundo","text":"Esta función toma un \"mundo\" (es decir, una lista con información acerca de su tamaño, paredes, \"cosos\" presentes y la ubicación y dirección de Karel), lo grafica y prepara todo para que Karel pueda realizar sus acciones. Siempre debe ser evaluada antes de que Karel empiece cumplir sus objetivos, en especial, si en algún momento hemos cometido un error, debemos comenzar de nuevo corriendo primero esta función.","code":""},{"path":"/reference/generar_mundo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generar el mundo de Karel — generar_mundo","text":"","code":"generar_mundo(mundo)"},{"path":"/reference/generar_mundo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generar el mundo de Karel — generar_mundo","text":"mundo Un caracter de largo 1 indicando el nombre de uno de los mundos que ya vienen en el paquete o un objeto de tipo lista con todos los componentes que debe tener un mundo (ver más abajo en Detalles).","code":""},{"path":"/reference/generar_mundo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generar el mundo de Karel — generar_mundo","text":"Dibuja el estado inicial del mundo de Karel y deja todo preparado   para comenzar registrar sus acciones.","code":""},{"path":"/reference/generar_mundo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generar el mundo de Karel — generar_mundo","text":"Luego de correr generar_mundo(), se ejecutan las acciones de Karel y se pueden visualizar con la función ejecutar_acciones(). El argumento mundo puede consistir de un mundo creado (es   decir, inventado) por cualquiera. En este caso, mundo debe ser una   lista con los siguientes componentes:  nx: TODO ny: hor_walls: ver_walls: karel_x: karel_y: karel_dir: beepers_x: beepers_y: beepers_n: beepers_bag:","code":""},{"path":[]},{"path":"/reference/generar_mundo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generar el mundo de Karel — generar_mundo","text":"","code":"generar_mundo(\"mundo001\")"},{"path":"/reference/generate_open_moves.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate array which shows moves that Karel can and can't make — generate_open_moves","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"function creates open_moves, nx x ny x 4 array TRUE/FALSE values indicating Karel can move direction given position. example, Karel bottom left corner, cell [1, 1], go south left, open_moves[1, 1, 3] open_moves[1, 1, 4] set FALSE. Depending existing walls move south north, open_moves[1, 1, 1] open_moves[1, 1, 2] TRUE FALSE.","code":""},{"path":"/reference/generate_open_moves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"","code":"generate_open_moves(nx, ny, hor_walls, ver_walls)"},{"path":"/reference/generate_open_moves.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"nx, ny size world hor_walls, ver_walls dataset horizontal vertical walls described details function generar_mundo.","code":""},{"path":"/reference/generate_open_moves.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"6nx x ny x 4 array TRUE/FALSE values","code":""},{"path":"/reference/generate_open_moves.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"Taking account size world walls, function properly defines array open_moves.","code":""},{"path":"/reference/generate_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Karel's world — generate_world","title":"Create Karel's world — generate_world","text":"function takes \"world\" (.e. list data size, walls, beepers Karel's position direction), plots prepares everything Karel can start performing actions . must run always Karel starts working goals, especially made mistake, must start first running function.","code":""},{"path":"/reference/generate_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Karel's world — generate_world","text":"","code":"generate_world(world)"},{"path":"/reference/generate_world.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Karel's world — generate_world","text":"world Character vector length 1 name one provided worlds package list provided user components world needs (see details).","code":""},{"path":"/reference/generate_world.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Karel's world — generate_world","text":"Plots initial state Karel's world prepares everything   start recording actions.","code":""},{"path":"/reference/generate_world.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Karel's world — generate_world","text":"running generate_mundo(), can run Karel's actions finally visualize function run_actions(). Argument world can create user. case,   must list following components:  nx: TODO ny: hor_walls: ver_walls: karel_x: karel_y: karel_dir: beepers_x: beepers_y: beepers_n: beepers_bag:","code":""},{"path":[]},{"path":"/reference/generate_world.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Karel's world — generate_world","text":"","code":"generate_world(\"mundo001\")"},{"path":"/reference/get_beepers_df_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Get row number in beepers dataset — get_beepers_df_row","title":"Get row number in beepers dataset — get_beepers_df_row","text":"Given current position Karel, calculates cell id (cell) returns row number respective cell beepers_now dataset. used add remove beepers row Karel picks puts beepers.","code":""},{"path":"/reference/get_beepers_df_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get row number in beepers dataset — get_beepers_df_row","text":"","code":"get_beepers_df_row()"},{"path":"/reference/get_beepers_df_row.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get row number in beepers dataset — get_beepers_df_row","text":"row number numeric length 0","code":""},{"path":"/reference/get_pkg_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Karel's environment — get_pkg_env","title":"Get Karel's environment — get_pkg_env","text":"function returns environment called pkg_env created package. useful debugging checking. internal function.","code":""},{"path":"/reference/get_pkg_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Karel's environment — get_pkg_env","text":"","code":"get_pkg_env()"},{"path":"/reference/get_pkg_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Karel's environment — get_pkg_env","text":"enviroment objects represent Karel's world.","code":""},{"path":"/reference/get_pkg_env.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Karel's environment — get_pkg_env","text":"pkg_env environment created inside package store   share functions objects related Karel's world   state. Since functions used students   simple without arguments (example, move()), functions   modify internally pkg_env. components environment : nx: TODO ny: hor_walls: ver_walls: open_moves: karel: dir_now: x_now: y_now: moment: beepers_any: beepers_bag: beepers_now: beepers_all: base_plot:","code":""},{"path":"/reference/global_env_set_hack.html","id":null,"dir":"Reference","previous_headings":"","what":"This function lets me add objects to another environment — global_env_set_hack","title":"This function lets me add objects to another environment — global_env_set_hack","text":"function lets add objects another environment","code":""},{"path":"/reference/global_env_set_hack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function lets me add objects to another environment — global_env_set_hack","text":"","code":"global_env_set_hack(key, val, pos)"},{"path":"/reference/global_env_set_hack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function lets me add objects to another environment — global_env_set_hack","text":"key name new object val object pos index environment","code":""},{"path":"/reference/load_super_karel.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn on Karel's superpowers — load_super_karel","title":"Turn on Karel's superpowers — load_super_karel","text":"running load_super_karel(), Karel can also turn right turn around turn_right() turn_around(). superpowers loaded, functions available Karel use .","code":""},{"path":"/reference/load_super_karel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn on Karel's superpowers — load_super_karel","text":"","code":"load_super_karel()"},{"path":"/reference/load_super_karel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn on Karel's superpowers — load_super_karel","text":"return anything attaches global environment   functions turn_right() turn_around().","code":""},{"path":[]},{"path":"/reference/load_super_karel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn on Karel's superpowers — load_super_karel","text":"","code":"generate_world(\"mundo001\")  load_super_karel() turn_around() turn_right() run_actions()"},{"path":"/reference/plot_base_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot base world — plot_base_world","title":"Plot base world — plot_base_world","text":"functions produces initial plot world, size walls . plot Karel beepers, since things can change time.","code":""},{"path":"/reference/plot_base_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot base world — plot_base_world","text":"","code":"plot_base_world()"},{"path":"/reference/plot_base_world.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot base world — plot_base_world","text":"ggplot world","code":""},{"path":"/reference/plot_static_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the world at a given time — plot_static_world","title":"Plot the world at a given time — plot_static_world","text":"function plots Karel'w wort requested time. Initially, time 1 action Karel performs, time incremented one. Current time stored pkg_env$moment. function useful debuggint get static images used examples handouts studentes.","code":""},{"path":"/reference/plot_static_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the world at a given time — plot_static_world","text":"","code":"plot_static_world(time)"},{"path":"/reference/plot_static_world.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the world at a given time — plot_static_world","text":"time requested time","code":""},{"path":"/reference/plot_static_world.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the world at a given time — plot_static_world","text":"Prints plot.","code":""},{"path":"/reference/put_hor_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Put horizontal walls (streets) — put_hor_walls","title":"Put horizontal walls (streets) — put_hor_walls","text":"Helper function generate_open_moves(). takes available data piece horizontal wall (x y coordinates beginning point length) produces dataset positions directions prohibited moves Karel wall.","code":""},{"path":"/reference/put_hor_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put horizontal walls (streets) — put_hor_walls","text":"","code":"put_hor_walls(x, y, lgth)"},{"path":"/reference/put_hor_walls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put horizontal walls (streets) — put_hor_walls","text":"x, y x y coordinates beginning point wall lgth length wall","code":""},{"path":"/reference/put_hor_walls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put horizontal walls (streets) — put_hor_walls","text":"lgth x 3 dataset coordinates Karel move   direction (side) towards move piece horizontal   wall.","code":""},{"path":"/reference/put_ver_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Put vertical walls (streets) — put_ver_walls","title":"Put vertical walls (streets) — put_ver_walls","text":"Helper function generate_open_moves(). takes available data piece vertical wall (x y coordinates beginning point length) produces dataset positions directions prohibited moves Karel wall.","code":""},{"path":"/reference/put_ver_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put vertical walls (streets) — put_ver_walls","text":"","code":"put_ver_walls(x, y, lgth)"},{"path":"/reference/put_ver_walls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put vertical walls (streets) — put_ver_walls","text":"x, y x y coordinates beginning point wall lgth length wall","code":""},{"path":"/reference/put_ver_walls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put vertical walls (streets) — put_ver_walls","text":"lgth x 3 dataset coordinates Karel move   direction (side) towards move piece vertical   wall.","code":""},{"path":"/reference/run_actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Run actions — run_actions","title":"Run actions — run_actions","text":"function produces animation shows actions performed Karel since world generated generate_world.","code":""},{"path":"/reference/run_actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run actions — run_actions","text":"","code":"run_actions(loop = TRUE)"},{"path":"/reference/run_actions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run actions — run_actions","text":"loop logical value TRUE FALSE indicating animation repeat finished (defaults TRUE).","code":""},{"path":"/reference/run_actions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run actions — run_actions","text":"Produces animation gganimate.","code":""},{"path":[]},{"path":"/reference/run_actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run actions — run_actions","text":"","code":"generate_world(\"mundo001\")  move() pick_beeper() turn_left() put_beeper() run_actions()"},{"path":"/news/index.html","id":"karel-0119000","dir":"Changelog","previous_headings":"","what":"karel 0.1.1.9000","title":"karel 0.1.1.9000","text":"current development version karel.","code":""},{"path":"/news/index.html","id":"karel-011","dir":"Changelog","previous_headings":"","what":"karel 0.1.1","title":"karel 0.1.1","text":"CRAN release: 2022-03-26 Fixed typo DESCRIPTION vignettes. Updated vignettes names indicate reading order added descriptions. Updated README link package website CRAN new badges.","code":""},{"path":"/news/index.html","id":"karel-010","dir":"Changelog","previous_headings":"","what":"karel 0.1.0","title":"karel 0.1.0","text":"CRAN release: 2021-08-06 Version first submission CRAN.","code":""},{"path":"/news/index.html","id":"karel-0019000","dir":"Changelog","previous_headings":"","what":"karel 0.0.1.9000","title":"karel 0.0.1.9000","text":"Improved description file. Added new worlds. Added mode prevent running actions without generating new world user made mistake. Added new vignettes several examples exercises.","code":""},{"path":"/news/index.html","id":"karel-0009000","dir":"Changelog","previous_headings":"","what":"karel 0.0.0.9000","title":"karel 0.0.0.9000","text":"first development version karel.","code":""}]
